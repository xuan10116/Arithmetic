package Test.JZ;
/*
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数
例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次
* */
public class JZ31 {
    //思路就是，统计每个 位数 上 1 出现的个数

    /**
     * 对于整数n，将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。
     * 我们从个位到最高位 依次计算每个位置出现1的次数：
     * 在计算时，会出现三种情况
     * 1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100-00199，01100-01199，……，20100-20199。一共有21*100种情况，即high*100;
     * 2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000-01999，11000-11999，21000-21034。一共有2*1000+（34+1）种情况，即high*1000+(low+1)。
     * 3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010-00019，……，21010-21019。一共有(210+1)*10种情况，即(high+1)*10。
     * 总结：
     * cur == 0
     * count += high*i;
     * cur == 1
     * count += high*i +(low+1);
     * cur >1
     * count += (high+1)*i;
     * @param n
     * @return
     */
    public int NumberOf1Between1AndN_Solution(int n) {
        int count = 0;
        //i代表位数，i=1，代表 个位 以此类推...
        for (int i = 1;i<=n;i*=10){
            int high = n/(i*10);//更高位的数字
            int low = (n%i); // 更低位的数字
            int cur = (n/i)%10; //当前位数字

            if(cur == 0){
                count += high*i;
            }else if (cur == 1){
                count += high*i +(low+1);
            }else{
                count += (high+1)*i;
            }
        }
        return count;
    }
}
